import{av as o,at as y,aw as S,ax as X,ay as M,az as I}from"./index-uPjlTW5-.js";function D(s,n){const e=o(s),a=o(n),t=e.getTime()-a.getTime();return t<0?-1:t>0?1:t}function O(s,n){const e=o(s),a=o(n),t=e.getFullYear()-a.getFullYear(),c=e.getMonth()-a.getMonth();return t*12+c}function T(s){return n=>{const a=(s?Math[s]:Math.trunc)(n);return a===0?0:a}}function _(s,n){return+o(s)-+o(n)}function Y(s){const n=o(s);return n.setHours(23,59,59,999),n}function R(s){const n=o(s),e=n.getMonth();return n.setFullYear(n.getFullYear(),e+1,0),n.setHours(23,59,59,999),n}function b(s){const n=o(s);return+Y(n)==+R(n)}function F(s,n){const e=o(s),a=o(n),t=D(e,a),c=Math.abs(O(e,a));let i;if(c<1)i=0;else{e.getMonth()===1&&e.getDate()>27&&e.setDate(30),e.setMonth(e.getMonth()-t*c);let r=D(e,a)===-t;b(o(s))&&c===1&&D(s,a)===1&&(r=!1),i=t*(c-Number(r))}return i===0?0:i}function v(s,n,e){const a=_(s,n)/1e3;return T(e==null?void 0:e.roundingMethod)(a)}function H(s,n,e){const a=I(),t=(e==null?void 0:e.locale)??a.locale??y,c=2520,i=D(s,n);if(isNaN(i))throw new RangeError("Invalid time value");const r=Object.assign({},e,{addSuffix:e==null?void 0:e.addSuffix,comparison:i});let h,m;i>0?(h=o(n),m=o(s)):(h=o(s),m=o(n));const l=v(m,h),x=(S(m)-S(h))/1e3,f=Math.round((l-x)/60);let d;if(f<2)return e!=null&&e.includeSeconds?l<5?t.formatDistance("lessThanXSeconds",5,r):l<10?t.formatDistance("lessThanXSeconds",10,r):l<20?t.formatDistance("lessThanXSeconds",20,r):l<40?t.formatDistance("halfAMinute",0,r):l<60?t.formatDistance("lessThanXMinutes",1,r):t.formatDistance("xMinutes",1,r):f===0?t.formatDistance("lessThanXMinutes",1,r):t.formatDistance("xMinutes",f,r);if(f<45)return t.formatDistance("xMinutes",f,r);if(f<90)return t.formatDistance("aboutXHours",1,r);if(f<X){const u=Math.round(f/60);return t.formatDistance("aboutXHours",u,r)}else{if(f<c)return t.formatDistance("xDays",1,r);if(f<M){const u=Math.round(f/X);return t.formatDistance("xDays",u,r)}else if(f<M*2)return d=Math.round(f/M),t.formatDistance("aboutXMonths",d,r)}if(d=F(m,h),d<12){const u=Math.round(f/M);return t.formatDistance("xMonths",u,r)}else{const u=d%12,g=Math.trunc(d/12);return u<3?t.formatDistance("aboutXYears",g,r):u<9?t.formatDistance("overXYears",g,r):t.formatDistance("almostXYears",g+1,r)}}export{H as f};
